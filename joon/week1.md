## IP 주소 (Internet Protocol Address)

- 컴퓨터를 네트워크 상에서 고유하게 식별하기 위한 주소이다.
- IP 주소는 겹치지 않아야 하며, 모든 컴퓨터가 고유한 IP 주소를 가져야 한다.
- 부족한 IP 주소를 해결하기 위해 사설 아이피 주소, NAT, 서브네팅, IPv6 등의기술이 사용된다.


## 포트 번호 (Port Number)

- 컴퓨터 내에서 여러 프로세스 간 통신을 구분하기 위한 식별 값이다.
- IP 주소로 컴퓨터를 식별한 후, 포트 번호로 특정 프로세스를 식별한다.
- 클라이언트가 서버로 데이터를 전송할 때, [서버의 IP 주소]:[포트 번호] 형태로 목적지를 지정한다.
- 예를 들어, [203.230.7.2:80]은 "203.230.7.2의 아이피 주소를 가진 컴퓨터의 80번 포트의 프로세스"를 의미한다.
  

## 데이터 송신 과정

1. Application(데이터를 송신하려는 서버 프로세스)
2. Sockets
3. 네트워크 Stack
4. NIC  
  
### 데이터를 송신 할 때

- 서버 프로세스가 운영체제의 write 시스템 콜을 통해 소켓에 데이터를 보냅니다.
- 송신된 데이터는 TCP/UDP 계층, IP 계층, 그리고 Ethernet을 거쳐 흐름 제어, 라우팅 등의 작업이 수행된다.
- 마지막으로 NIC(랜 카드)를 통해 외부로 데이터를 전송한다.  
  
### 데이터를 수신 할 때:

- 데이터 수신 시, NIC에서 데이터를 수신하고, 인터럽트를 통해 Driver로 데이터를 전달한다.
- 네트워크 스택에서 데이터가 처리되며, 소켓에 데이터가 담기고, 최종적으로 수신 대상이 되는 프로세스에 데이터가 도달하게 된다.


  

# 소켓

## socket()

> 프로세스가 네트워크 통신에 사용할 소켓을 생성합니다. 소켓은 데이터 송수신을 위한 인터페이스 역할을 한다.

<aside>
  
**_socket(domain, type, protocol )_**;
---
  
**_domain_** : IPv4, IPv6중 무엇을 사용할지 결정

**_type_** : stream, datagram 소켓 중 선택

**_protocol_** : 0, 6, 17 중 0을 넣으면 시스템이 프로토콜을 선택하며, 6이면 tcp, 17이면 udp

</aside>

  

    

## bind()

> 소켓에 특정 네트워크 주소와 포트 번호를 할당하는 역할을 한다. 주로 서버 소켓에서 사용되며, 클라이언트가 서버에 접속할 때 사용할 IP 주소와 포트 번호를 설정한다.


<aside>
  
**_bind(sockfd, sockaddr, socklen_t)_**
---
  
**_sockfd_**: 바인딩을 할 소켓의 파일 디스크립터

**_sockaddr_**: 소켓에 바인딩 할 아이피 주소, 포트번호를 담은 구조체

**socklen_t_** : 위 구조체의 메모리 크기

</aside>


    
  


## listen()

> 서버가 클라이언트의 연결을 대기하고 처리할 수 있도록 하며, 클라이언트의 연결 요청을 받아들이기 위한 준비를 마치는 단계이다. TCP에서만 사용한다.

<aside>

**_listen(sockfd, backlog)_**
---
  
**_sockfd :_** 소켓의 파일 디스크립터

**_backlog :_** 연결요청을 받아줄 크기 = TCP의 backlog 큐의 크기

</aside>




   
    

## accept()

> 서버 소켓에서 클라이언트의 연결 요청을 수락하고, 클라이언트와 통신할 수 있는 새로운 소켓을 생성하는 역할을 한다.

<aside>
  
**_int accept(sockfd, sockaddr , socklen_t);_**
---
  
**_sockfd :_** backlog 큐의 요청을 받아들이기 위한 소켓의 파일 디스크립터

**_sockaddr :_** 선입선출로 빼온 연결 요청에서 알아낸 클라이언트의 주소 정보

**_socklen_t :_** 위 구조체의 메모리 크기

</aside>




      


## 멀티 스레드 기반 서버

> 여러 스레드를 사용하여 동시에 여러 클라이언트 요청을 처리하는 서버 모델이다. 이 모델은 다수의 스레드가 서로 다른 클라이언트와 독립적으로 작업하며, 동시에 다수의 연결을 처리할 수 있어 효율적이고 확장성이 뛰어나다.

1. 스레드 생성 및 관리:

- 멀티 스레드 서버는 클라이언트 연결 요청이 들어올 때마다 새로운 스레드를 생성하거나 미리 생성한 스레드 풀에서 스레드를 가져와 할당합니다.
- 스레드 풀을 사용하면 스레드 생성 및 소멸에 따른 오버헤드를 줄일 수 있습니다.

2. 병렬 처리:

- 멀티 스레드 서버는 여러 스레드가 병렬로 클라이언트 요청을 동시에 처리할 수 있습니다.
- 다수의 클라이언트에 대한 응답 속도가 빨라집니다.

3. 스레드 간 데이터 공유:

- 멀티 스레드 서버에서는 여러 스레드가 서버 자원에 동시에 접근할 수 있으므로 스레드 간 동기화와 데이터 공유에 주의해야 합니다.
- 공유 자원에 대한 안전한 접근을 위해 뮤텍스, 세마포어, 조건 변수 등의 동기화 메커니즘을 사용합니다.

4. 스케일 아웃 (Scaling Out):

- 멀티 스레드 기반 서버는 스레드를 추가하거나 제거하여 서버의 성능을 스케일 아웃할 수 있습니다.
- 더 많은 클라이언트 요청을 처리하기 위해 서버를 확장할 수 있습니다.

5. 단점과 주의사항:

- 멀티 스레드 서버는 스레드 간 동기화와 공유 자원 관리에 대한 복잡성을 가질 수 있습니다.
- 스레드가 많이 생성되면 컨텍스트 스위칭 오버헤드가 발생할 수 있으므로 스레드 풀의 크기와 관리가 중요합니다.
